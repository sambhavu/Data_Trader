#include <cmath>
#include <vector>
#include <iostream>
#include <string>
using namespace std; 

#ifndef Pi 
#define Pi 3.141592653589793238462643 
#endif 

const double EURUSD[679] = {
    
1.116300, 
1.116300, 
1.116440, 
1.116440, 
1.116340, 
1.116110, 
1.116170, 
1.116140, 
1.116170, 
1.116360, 
1.116380, 
1.116380, 
1.116350, 
1.116360, 
1.116220, 
1.116250, 
1.116310, 
1.116370, 
1.116360, 
1.116410, 
1.116390, 
1.116370, 
1.116350, 
1.116410, 
1.116380, 
1.116310, 
1.116180, 
1.116210, 
1.116430, 
1.116550, 
1.116430, 
1.116540, 
1.116570, 
1.116640, 
1.116640, 
1.116730, 
1.116730, 
1.116840, 
1.116820, 
1.116800, 
1.116830, 
1.116900, 
1.116880, 
1.116890, 
1.116890, 
1.116870, 
1.116900, 
1.116900, 
1.116870, 
1.116860, 
1.116860, 
1.116830, 
1.116830, 
1.116830, 
1.116840, 
1.116830, 
1.116770, 
1.116740, 
1.116790, 
1.116910, 
1.117050, 
1.117120, 
1.117160, 
1.117180, 
1.117150, 
1.117150, 
1.117260, 
1.117230, 
1.117210, 
1.117180, 
1.117180, 
1.117150, 
1.117230, 
1.117180, 
1.117190, 
1.117250, 
1.117240, 
1.117230, 
1.117220, 
1.117170, 
1.117170, 
1.117130, 
1.117120, 
1.117010, 
1.117120, 
1.117130, 
1.117130, 
1.117070, 
1.117030, 
1.116970, 
1.116950, 
1.117010, 
1.116960, 
1.117000, 
1.116960, 
1.117060, 
1.117070, 
1.117080, 
1.117070, 
1.117230, 
1.117180, 
1.117240, 
1.117240, 
1.117130, 
1.117070, 
1.117110, 
1.117120, 
1.117230, 
1.117280, 
1.117270, 
1.117320, 
1.117370, 
1.117320, 
1.117330, 
1.117270, 
1.117280, 
1.117210, 
1.117230, 
1.117170, 
1.117240, 
1.117190, 
1.117240, 
1.117180, 
1.117140, 
1.117180, 
1.117180, 
1.117120, 
1.117060, 
1.117200, 
1.117170, 
1.117170, 
1.117230, 
1.117170, 
1.117190, 
1.117190, 
1.117180, 
1.117130, 
1.117170, 
1.117220, 
1.117180, 
1.117270, 
1.117280, 
1.117260, 
1.117280, 
1.117260, 
1.117210, 
1.117170, 
1.117210, 
1.117170, 
1.117160, 
1.117110, 
1.117120, 
1.117110, 
1.117210, 
1.117260, 
1.117260, 
1.117230, 
1.117210, 
1.117160, 
1.117260, 
1.117270, 
1.117260, 
1.117310, 
1.117300, 
1.117360, 
1.117400, 
1.117400, 
1.117310, 
1.117300, 
1.117320, 
1.117300, 
1.117340, 
1.117300, 
1.117350, 
1.117260, 
1.117300, 
1.117300, 
1.117350, 
1.117360, 
1.117300, 
1.117290, 
1.117570, 
1.117440, 
1.117520, 
1.117520, 
1.117630, 
1.117630, 
1.117640, 
1.117710, 
1.117780, 
1.117820, 
1.117850, 
1.117860, 
1.117820, 
1.117750, 
1.117660, 
1.117710, 
1.117760, 
1.117770, 
1.117820, 
1.117820, 
1.117870, 
1.117860, 
1.117900, 
1.117900, 
1.117930, 
1.117920, 
1.117870, 
1.117860, 
1.117850, 
1.117780, 
1.117910, 
1.117900, 
1.117890, 
1.117900, 
1.117950, 
1.117910, 
1.117910, 
1.117900, 
1.117920, 
1.117990, 
1.118050, 
1.118060, 
1.117980, 
1.117950, 
1.117950, 
1.117970, 
1.117950, 
1.118050, 
1.118080, 
1.118100, 
1.118080, 
1.118020, 
1.118010, 
1.117990, 
1.117950, 
1.117840, 
1.117930, 
1.117920, 
1.117800, 
1.117810, 
1.117940, 
1.117910, 
1.117900, 
1.117860, 
1.117860, 
1.117790, 
1.117740, 
1.117710, 
1.117690, 
1.117690, 
1.117650, 
1.117640, 
1.117650, 
1.117660, 
1.117680, 
1.117650, 
1.117630, 
1.117580, 
1.117640, 
1.117640, 
1.117750, 
1.117750, 
1.117880, 
1.117860, 
1.117800, 
1.117860, 
1.117960, 
1.117910, 
1.118040, 
1.117910, 
1.117960, 
1.118170, 
1.118210, 
1.118290, 
1.118470, 
1.118440, 
1.118520, 
1.118520, 
1.118450, 
1.118360, 
1.118430, 
1.118430, 
1.118220, 
1.118420, 
1.118270, 
1.118330, 
1.118330, 
1.118240, 
1.118270, 
1.118440, 
1.118520, 
1.118530, 
1.118510, 
1.118500, 
1.118440, 
1.118480, 
1.118440, 
1.118450, 
1.118420, 
1.118420, 
1.118360, 
1.118350, 
1.118350, 
1.118420, 
1.118450, 
1.118440, 
1.118460, 
1.118380, 
1.118380, 
1.118350, 
1.118310, 
1.118270, 
1.118250, 
1.118320, 
1.118340, 
1.118400, 
1.118400, 
1.118440, 
1.118460, 
1.118530, 
1.118500, 
1.118470, 
1.118500, 
1.118510, 
1.118560, 
1.118520, 
1.118550, 
1.118530, 
1.118570, 
1.118540, 
1.118530, 
1.118540, 
1.118490, 
1.118470, 
1.118480, 
1.118490, 
1.118410, 
1.118450, 
1.118500, 
1.118460, 
1.118450, 
1.118430, 
1.118520, 
1.118580, 
1.118660, 
1.118650, 
1.118660, 
1.118650, 
1.118650, 
1.118660, 
1.118610, 
1.118580, 
1.118610, 
1.118660, 
1.118660, 
1.118700, 
1.118710, 
1.118810, 
1.118820, 
1.118780, 
1.118830, 
1.118850, 
1.118860, 
1.118760, 
1.118780, 
1.118830, 
1.118930, 
1.118910, 
1.118850, 
1.118900, 
1.118880, 
1.118920, 
1.118900, 
1.118920, 
1.118870, 
1.118880, 
1.118900, 
1.118870, 
1.118810, 
1.118810, 
1.118750, 
1.118750, 
1.118650, 
1.118600, 
1.118510, 
1.118530, 
1.118490, 
1.118500, 
1.118480, 
1.118490, 
1.118470, 
1.118430, 
1.118430, 
1.118450, 
1.118460, 
1.118470, 
1.118480, 
1.118470, 
1.118360, 
1.118400, 
1.118450, 
1.118410, 
1.118390, 
1.118450, 
1.118460, 
1.118500, 
1.118520, 
1.118510, 
1.118560, 
1.118600, 
1.118570, 
1.118560, 
1.118560, 
1.118560, 
1.118520, 
1.118500, 
1.118490, 
1.118460, 
1.118450, 
1.118470, 
1.118520, 
1.118530, 
1.118490, 
1.118500, 
1.118470, 
1.118450, 
1.118440, 
1.118410, 
1.118400, 
1.118390, 
1.118390, 
1.118390, 
1.118390, 
1.118380, 
1.118390, 
1.118390, 
1.118390, 
1.118380, 
1.118400, 
1.118360, 
1.118390, 
1.118400, 
1.118400, 
1.118330, 
1.118250, 
1.118250, 
1.118250, 
1.118300, 
1.118260, 
1.118250, 
1.118220, 
1.118190, 
1.118230, 
1.118240, 
1.118250, 
1.118300, 
1.118270, 
1.118260, 
1.118310, 
1.118310, 
1.118310, 
1.118300, 
1.118300, 
1.118200, 
1.118190, 
1.118140, 
1.118140, 
1.118140, 
1.118140, 
1.118120, 
1.118100, 
1.118040, 
1.117980, 
1.117890, 
1.117700, 
1.117700, 
1.117680, 
1.117730, 
1.117710, 
1.117700, 
1.117700, 
1.117650, 
1.117630, 
1.117640, 
1.117660, 
1.117700, 
1.117650, 
1.117690, 
1.117700, 
1.117710, 
1.117710, 
1.117760, 
1.117810, 
1.117790, 
1.117800, 
1.117850, 
1.117840, 
1.117810, 
1.117850, 
1.117850, 
1.117860, 
1.117910, 
1.117870, 
1.117900, 
1.117860, 
1.117870, 
1.117850, 
1.117750, 
1.117760, 
1.117750, 
1.117760, 
1.117810, 
1.117790, 
1.117800, 
1.117800, 
1.117810, 
1.117750, 
1.117810, 
1.117750, 
1.117760, 
1.117660, 
1.117610, 
1.117650, 
1.117600, 
1.117480, 
1.117490, 
1.117450, 
1.117490, 
1.117460, 
1.117500, 
1.117500, 
1.117510, 
1.117510, 
1.117540, 
1.117500, 
1.117520, 
1.117470, 
1.117520, 
1.117610, 
1.117340, 
1.117310, 
1.117300, 
1.117370, 
1.117390, 
1.117500, 
1.117490, 
1.117400, 
1.117450, 
1.117500, 
1.117490, 
1.117420, 
1.117260, 
1.117460, 
1.117160, 
1.117090, 
1.117150, 
1.117190, 
1.117090, 
1.116970, 
1.117000, 
1.117070, 
1.117180, 
1.117210, 
1.117140, 
1.117100, 
1.117100, 
1.116990, 
1.117050, 
1.116870, 
1.116850, 
1.116950, 
1.116910, 
1.116900, 
1.116750, 
1.116750, 
1.116750, 
1.116760, 
1.116860, 
1.116890, 
1.116930, 
1.116950, 
1.116780, 
1.116320, 
1.116280, 
1.116310, 
1.116450, 
1.116480, 
1.116480, 
1.116570, 
1.116560, 
1.116510, 
1.116560, 
1.116450, 
1.116410, 
1.116310, 
1.116210, 
1.116370, 
1.116220, 
1.116220, 
1.116390, 
1.116530, 
1.116550, 
1.116560, 
1.116610, 
1.116570, 
1.116620, 
1.116580, 
1.116660, 
1.116720, 
1.116780, 
1.116820, 
1.116740, 
1.116570, 
1.116750, 
1.116990, 
1.116650, 
1.116860, 
1.117070, 
1.116920, 
1.116930, 
1.117070, 
1.117130, 
1.117120, 
1.117130, 
1.116910, 
1.117010, 
1.116820, 
1.116880, 
1.116970, 
1.117030, 
1.117130, 
1.117000, 
1.116830, 
1.116660, 
1.116530, 
1.116600, 
1.116530, 
1.116550, 
1.116660, 
1.116720, 
1.116490, 
1.116840, 
1.116740, 
1.116830, 
1.116970, 
1.117160, 
1.117070, 
1.117070, 
1.117230, 
1.117270, 
1.117300, 
1.117140, 
1.117100, 
1.117250, 
1.117080, 
1.117180, 
1.117270, 
1.117270, 
1.117230, 
1.117320, 
1.117270, 
1.117090, 
1.116870, 
1.116820, 
1.116820, 
1.116790, 
1.116650, 
1.116720, 
1.116900, 
1.117150, 
1.117200, 
1.117110, 
1.117030, 
1.117270, 
1.117230, 
1.117200, 
1.117040, 
1.117000, 

};

class FX{
    public: 
    
    vector<double> get_walk (double z, double y);
    
    void MA_trader(); 
    
    double alpha;
};



vector<double> FX :: get_walk(double z, double y){
    
    vector<double> walk; 

    double m0 = z; 
    double vol = y; 
    double x = m0;
    
    double normalrandom;
    double change; 
    double prev = m0; 
    
    double L, K, w ;
    
    
        for(int j = 0; j<679; j++) { 
                change = 0;
                /*

            
                u1 = ( (double)(rand()) + 1.0 )/( (double)(RAND_MAX) + 1.0);
                u2 = ( (double)(rand()) + 1.0 )/( (double)(RAND_MAX) + 1.0);
                normalrandom = cos(8*atan(1.0)*u2)*sqrt(-2*log(u1));
                
                */
                
                   
                double u1,u2, v1, v2;
                double S = 2;
 
                while(S>=1){
     
                u1 = double(rand())/double(RAND_MAX);
                u2 = double(rand())/double(RAND_MAX);
 
                v1 = 2.0*u1-1.0;
                v2 = 2.0*u2-1.0;
 
                S = pow(v1,2)+pow(v2,2);
                };

                double normalrandom = v1*sqrt((-2.0*log(S))/S);
 

                //cout<<normalrandom<<", ";
                
                m0 = m0 + (normalrandom*vol);     
                
                walk.push_back(m0); 
                
            
        
            
            }
        return walk;
}   
    



void FX:: MA_trader(){
    
    double numbers = 679;
    double n = 1/(numbers-1); 
    double sum1 = 0;
    double mean1 = 0; 
    double stdev1 = 0;
    
    int flip = 0;
    double sum = 0; 
    double MA15; 
    double profit = 0;
    double sumprofit = 0;
    
    double r_sum; 
    double r_MA15; 
    double r_profit; 
    double r_sumprofit;
    int r_flip = 0; 
    
    
    
    for(int i =0; i<numbers; i++){                  //SQRT CALC
      sum1 += EURUSD[i]; 
    }
    mean1 = sum1/numbers;
    for(int i = 0; i<numbers; i++){
        stdev1 +=pow((EURUSD[i] - mean1),2);
    }
    stdev1 = sqrt((n*stdev1));
    //cout<<mean1<<"\n";
    vector<double> eurusd_randomwalk = get_walk(mean1,stdev1);
    
    for(int i = 0; i<679; i++){
        if(i>15)
        {
            
            profit = 0;
            sum = 0;
            
            r_profit = 0; 
            r_sum = 0; 
            
            double count =0;
            
            for(int j = i-15;j<i;j++){          //moving average calc
                
                sum += EURUSD[j];
                r_sum += eurusd_randomwalk[i];
                count++;
            }
            MA15 = sum/count;
            r_MA15 = r_sum/count;
            
            
            if(flip ==0){
                
                if(EURUSD[i-1]>MA15){                       //bullish trend
                    profit = 1000*(EURUSD[i]-EURUSD[i-1]);   
                }
            
                if(EURUSD[i-1]<MA15){                        //bearish trend
                    profit = 1000*(EURUSD[i-1]-EURUSD[i]);    
                }
                
            }
            
            if(flip == 1){
                
                if(EURUSD[i-1]>MA15){                           // reverse bullish trend 
                    profit = 1000*(EURUSD[i-1]-EURUSD[i]); 
                }
            
                if(EURUSD[i-1]<MA15){                           //reverse  bearish trend FLIP
                    profit = 1000*(EURUSD[i]-EURUSD[i-1]); 
                }
            }
            
            if(profit>0) {flip = 0;}
            if(profit<0){
                if(flip == 1){flip = 0;}
                else {flip = 1;}
            }
            //cout<<profit<<", ";
            sumprofit += profit;
            
            //RANDOMWALK STRATEGY BELOW
            
            if(r_flip ==0){
                
                if(eurusd_randomwalk[i-1]>r_MA15){                       //bullish trend
                    r_profit = 1000*(eurusd_randomwalk[i]-eurusd_randomwalk[i-1]);   
                }
            
                if(eurusd_randomwalk[i-1]<MA15){                        //bearish trend
                    r_profit = 1000*(eurusd_randomwalk[i-1]-eurusd_randomwalk[i]);    
                }
                
            }
            
            if(r_flip == 1){
                
                if(eurusd_randomwalk[i-1]>r_MA15){                           // reverse bullish trend 
                    r_profit = 1000*(eurusd_randomwalk[i-1]-eurusd_randomwalk[i]); 
                }
            
                if(eurusd_randomwalk[i-1]<MA15){                           //reverse  bearish trend FLIP
                    r_profit = 1000*(eurusd_randomwalk[i]-eurusd_randomwalk[i-1]);
                }
            }
            
            if(r_profit>0) {r_flip = 0;}
            if(r_profit<0){
                if(r_flip == 1){r_flip = 0;}
                else {r_flip = 1;}
            }
            //cout<<r_profit<<"\n";
            r_sumprofit += r_profit;
            
            alpha = sumprofit - r_sumprofit;
            //cout<<sumprofit<<", "<<r_sumprofit<<"\n";
            
            //cout<<alpha<<", ";
            
        }//end of trading area
        //cout<<EURUSD[i]<<", ";
        cout<<eurusd_randomwalk[i]<<", ";
        
        
    }//end of for loop 
    
}

int main()
{
FX algo; 
algo.MA_trader();
return 0;  
}
